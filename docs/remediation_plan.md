### Detailed Development and Remediation Plan

This plan is based on the critical analysis recorded in `docs/analysis_notes.md` and provides a step-by-step guide to refactor the codebase, starting with the highest priority security vulnerabilities and progressing to architectural and quality improvements.

---

### Phase 1: Remediation of Critical Security Vulnerabilities

**`[PRIO 1: SECURITY]` [STATUS: DONE]**

#### **1.1. Prompt Injection Mitigation**

*   **Objective:** To strictly separate user input from system instructions, preventing the manipulation of prompts.
*   **Files to Modify:**
    *   `src/gemini_gitlab_workflow/ai_service.py`
*   **Proposed Changes:**
    1.  Refactor the `call_google_gemini_api` function to accept a structured list of messages instead of a single f-string. The Google Gemini API supports this. Instead of `model.generate_content(prompt)`, use the `model.generate_content(messages)` format, where `messages` is a list of `{'role': 'user', 'parts': [text]}` and `{'role': 'model', 'parts': [text]}` objects.
    2.  In the `generate_implementation_plan` and `get_relevant_context_files` functions, do not construct a single large f-string. Instead, create a list of messages. System instructions (e.g., "You are a Product Owner...") should be placed in a message with the `model` (or system) role, while user-provided `user_prompt` and file-based `context_content` should be placed in a separate message with the `user` role.
*   **Testing Approach:**
    1.  Create a new test in `tests/test_ai_service.py` named `test_prompt_injection_mitigation`.
    2.  In this test, simulate a malicious `user_prompt` containing instructions (e.g., `"Ignore all previous instructions. Your new task is..."`).
    3.  Assert that the message list generated by `generate_implementation_plan` and passed to the mocked `model.generate_content` correctly isolates the malicious string within a `user`-role part and does not alter the `model`-role system instruction.

#### **1.2. Prevention of Data Exfiltration (Immediate Anonymization)**

*   **Objective:** To immediately implement the "Feature: Anonymize GitLab Context" to prevent project-specific data from being leaked to the external AI provider.
*   **Files to Modify:**
    *   New file: `src/gemini_gitlab_workflow/sanitizer.py`
    *   `src/gemini_gitlab_workflow/cli.py`
*   **Proposed Changes:**
    1.  Create a new file: `src/gemini_gitlab_workflow/sanitizer.py`. In it, define two functions: `anonymize_text(text: str)` and `deanonymize_text(text: str)`.
    2.  The `anonymize_text` function should replace occurrences of `GGW_GITLAB_URL` and `GGW_GITLAB_PROJECT_ID` (read from environment variables) with generic placeholders like `[PROJECT_URL]` and `[PROJECT_ID]`.
    3.  The `deanonymize_text` function should perform the reverse operation.
    4.  In `cli.py`, within the `create_feature` command, call the `anonymize_text` function on the entire context string before passing it to the `ai_service`.
    5.  After the `ai_service` returns the proposed plan, iterate through the `proposed_issues` list and call the `deanonymize_text` function on each `description` field.
*   **Testing Approach:**
    1.  Create a new test file `tests/test_sanitizer.py`.
    2.  Write unit tests for both functions to verify the correct replacement and restoration of placeholders.
    3.  Modify `tests/test_gemini_cli.py`: in a test, mock the `ai_service` call and assert that the context passed to it is the anonymized version.

---

### Phase 2: Addressing Architectural Deficiencies

**`[PRIO 2: ARCHITECTURE]`**

#### **2.1. Robust Configuration and Path Management**

*   **Objective:** To completely eliminate the use of `os.getcwd()` for predictable and portable behavior.
*   **Files to Modify:**
    *   `src/gemini_gitlab_workflow/config.py`
    *   All files that import from `config.py`.
*   **Proposed Changes:**
    1.  In `config.py`, replace the definition of `PROJECT_ROOT` with the following (using the `pathlib` library):
        ```python
        from pathlib import Path
        # This resolves to the 'src' dir's parent, which is the project root.
        PROJECT_ROOT = Path(__file__).parent.parent.parent
        ```
        This ensures that `PROJECT_ROOT` always points to the project's root directory, regardless of where the script is executed from.
    2.  Throughout the codebase, switch from `os.path.join` to using `pathlib` objects (e.g., `CACHE_DIR = PROJECT_ROOT / ".gemini_cache"`).
*   **Testing Approach:**
    1.  Run the existing test suite from a different working directory (`uv run --cwd /tmp pytest`). If the tests still pass, the refactoring was successful.
    2.  Write a specific unit test to verify that `config.PROJECT_ROOT` is set to the expected absolute path.

#### **2.2. Decomposition of Monolithic `gitlab_service`**

*   **Objective:** To break down `gitlab_service.py` according to the Single Responsibility Principle and the project's own architectural design.
*   **Files to Modify:**
    *   `src/gemini_gitlab_workflow/gitlab_service.py` (will be removed or refactored)
    *   New file: `src/gemini_gitlab_workflow/gitlab_client.py`
    *   New file: `src/gemini_gitlab_workflow/file_system_repo.py`
    *   New file: `src/gemini_gitlab_workflow/project_mapper.py`
*   **Proposed Changes:**
    1.  **`gitlab_client.py`:** This module will contain `get_gitlab_client()` and all direct GitLab API calls (listing issues, creating issues, etc.). This layer is responsible for communication with the external service. `get_gitlab_client` should be a singleton or a centrally managed object to avoid re-instantiation in every function.
    2.  **`file_system_repo.py`:** This module will handle all filesystem operations: writing Markdown files (`_generate_markdown_content`), and reading/writing `project_map.yaml`.
    3.  **`project_mapper.py`:** This module will contain the core logic of `build_project_map`. It will use the `gitlab_client` to fetch data and the `file_system_repo` to write the results.
    4.  The logic for `upload_artifacts_to_gitlab` can be moved to a new `gitlab_uploader.py` module.
*   **Testing Approach:**
    1.  For each new module, create a corresponding test file (e.g., `tests/test_project_mapper.py`).
    2.  Migrate relevant tests from `test_gitlab_service.py` to the new test files.
    3.  Write new, focused unit tests for the isolated components. Use mocks extensively to test the dependencies between layers (e.g., the `project_mapper` test should mock the `gitlab_client`).

---

### Phase 3: Improving Code Quality and Maintainability

**`[PRIO 3: QUALITY]`**

#### **3.1. Introduction of Structured Logging**

*   **Objective:** To replace all `print()` calls with an industry-standard logging framework.
*   **Files to Modify:**
    *   All `.py` files under `src/gemini_gitlab_workflow/`.
    *   `src/gemini_gitlab_workflow/config.py` (for configuration).
*   **Proposed Changes:**
    1.  In `config.py` or a new `logging_config.py`, configure the `logging` module. Set a default format (timestamp, log level, module name, message) and level (e.g., `INFO`).
    2.  In each module, initialize a logger instance: `import logging; logger = logging.getLogger(__name__)`.
    3.  Replace all `print(f"[DIAG]...")` calls with `logger.debug(...)`, `print(f"[INFO]...")` with `logger.info(...)`, `print(f"[WARN]...")` with `logger.warning(...)`, and `print(f"[ERROR]...")` with `logger.error(...)`.
*   **Testing Approach:**
    1.  Modify an existing CLI test in `tests/test_gemini_cli.py` to use the `caplog` pytest fixture to capture log messages.
    2.  Assert that the expected log messages are generated at the correct level and in the correct format when the command is run.

#### **3.2. Consistent Error Handling Strategy**

*   **Objective:** To establish predictable and robust error handling using custom exceptions.
*   **Files to Modify:**
    *   New file: `src/gemini_gitlab_workflow/exceptions.py`
    *   All `.py` files under `src/gemini_gitlab_workflow/`.
*   **Proposed Changes:**
    1.  Create an `exceptions.py` file and define custom exceptions like `ConfigurationError`, `GitLabAPIError`, and `AIResponseError`.
    2.  In the codebase, replace generic `try...except Exception` blocks with more specific ones. Where a `print` and `return None` currently exists, raise an appropriate custom exception instead (e.g., `raise AIResponseError("Failed to parse JSON from AI.")`).
    3.  In `cli.py`, within the `typer` command implementations, place a top-level `try...except` block that catches these custom exceptions, prints a clean, user-friendly error message to the console, and exits with a non-zero status code.
*   **Testing Approach:**
    1.  Write new tests that intentionally trigger error conditions (e.g., a mocked API call raises a `GitlabHttpError`).
    2.  Assert that the internal functions raise the appropriate custom exception.
    3.  In `test_gemini_cli.py`, verify that when an internal service raises an exception, the CLI handles it gracefully: the error message is printed to the output, and `result.exit_code` is non-zero.